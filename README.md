# Eleven

低成本可落地的 DDD 技术方案脚手架。

## 项目介绍
Eleven 是一个低成本可落地的 DDD（领域驱动设计）技术方案脚手架，
旨在帮助开发者快速搭建基于 DDD 思想的项目架构。

1. 明确层次划分与职责分离，采用典型四层架构（用户界面层、应用层、领域层、基础设施层）
2. 用户界面层处理用户交互，不包含业务逻辑，仅调用应用层接口
3. 应用层作为协调者编排操作，定义粗粒度服务，处理事务、权限等，不包含核心业务逻辑
4. 领域层封装核心业务逻辑，包含领域模型、服务、事件，独立于技术实现
5. 基础设施层提供技术支撑，实现上层定义的抽象接口（如仓储），对上层透明
6. 上层依赖下层抽象（依赖倒置），如应用层依赖领域层接口而非基础设施具体实现
7. 禁止下层反向依赖上层（如基础设施层不依赖领域层/应用层）
8. 领域模型独立于技术细节，不含框架注解（如JPA）或数据库相关代码
9. 通过防腐层（ACL）隔离外部系统，转换外部模型为领域模型
10. 层间接口使用通用语言（Ubiquitous Language），符合业务术语
11. 通过DTO解耦层间数据格式，UI层与应用层交互使用DTO，不暴露领域模型
12. 禁止跨层直接访问（如UI层不绕过应用层调用领域层）
13. 每层可独立演进，更换技术实现（如UI框架、数据库）不影响其他层
14. 分离业务规则与技术规则，业务逻辑集中在领域层，技术细节在基础设施层
15. 应用层处理事务边界和全局流程控制，领域层不涉及事务提交等技术逻辑
16. 领域事件在领域层定义，由基础设施层实现发布/订阅，解耦跨领域协作
17. 测试分层进行，每层测试独立（如领域层单元测试不依赖数据库）

## 分层设计
- xxxService：Bean 级别的 Application service
    - xxxManager：Bean 级别的 domain service，作为为应用提供通用逻辑的服务，不放在领域层
        - xxxSupport：Bean 级别业务公共方法类
            - xxxEr/Or：Bean 级别的底层工具类，无层级依赖，通常为业务级别的工具
                - xxxUtil：与业务无关的静态工具类
                - xxxHelper：与业务相关的静态工具类
                - xxxContext：与框架相关的静态工具类

## 聚合设计

### 技术需求

**架构师+技术经理+技术团队**根据领域驱动设计对领域模型的需求描述，团队决定先对业务建模，并且遵循如下规则：

- **实体**
  - 具有唯一标识符（ID）。
  - 生命周期需显式管理，状态变化通过业务操作实现。
  - 封装业务逻辑，避免贫血模型。
  - 在聚合内的ID仅需局部唯一，由聚合根统一管理。
  - 不能直接引用其他聚合的实体，需通过聚合根ID关联。

- **聚合根**
  - 聚合的**唯一入口**点，外部只能通过聚合根ID访问聚合内部对象。
  - 具有**全局唯一ID**，控制聚合内实体的生命周期。
  - **边界保护**：聚合内业务规则必须通过聚合根校验。
  - **小巧设计**：聚合应尽可能小，避免包含无关实体。
  - **标识符引用**：外部仅能通过聚合根ID引用其他聚合，禁止直接关联内部实体。

- **值对象**
  - **无唯一标识**符，通过属性值定义身份。
  - **不可变性**：创建后属性不可修改，状态变化需创建新实例。
  - **无生命周期**，作为数据载体存在。
  - 通过属性值比较相等性，而非引用比较。

- **领域服务**
  - 包含了业务领域的核心逻辑。
  - 可对多个实体对象，或者聚合根进行操作。
  - 不包含任何技术层面实现，比如事务，GUI。
  - 如果需要依赖某些技术手段，将其封装为接口进行依赖。

### 技术实现
- **技术经理和团队开始定义领域模型的技术范围**
  - 领域模型**必须**包含领域实体
  - 领域模型**必须**包含领域聚合根
  - 领域模型**必须**包含领域实体仓库接口
  - 领域模型**必须**包含领域事件
  - 领域模型**必须**包含领域聚合根查询能力（即读操作）
  - 领域模型**必须**包含领域聚合根操作能力（即写操作）
  - 领域模型**必须**包含领域业务规则
  - 领域模型**可以**包含复杂逻辑的设计模型
- **技术经理和团队开始定义领域模型的技术手段**
  - 使用JPA标记实体类，暂时不考虑实体类与存储技术解耦，因为技术团队目前很熟练jpa，而且预估未来不会出现替换持久化技术的可能。
  - 使用cqrs实现读写分离，加大力度保证单一职责原则，即一个方法要么执行写入，要么执行读取。
  - 使用《领域驱动设计》原书中的对象规格（domain spec）技术手段，来查询对象。
  - 让领域服务后缀为Manager，来区分领域服务和应用服务
  - 让领域服务来之行领域模型业务的代理，同时管理领域事件，这一点是因为一些技术条件限制
- **架构师开始评审技范围和技术手段**
  - 要求团队将实现手段写成文档，作为核心技术文档好好保管
  - 要求代码评审的时候按照原则逐条评审，不允许有人轻易破坏规则
  - 提出了很多其他技术管理需求

## 接口设计

### 状态码约定
状态码采用 HTTP 标准状态码，统一处理器为 `RestApiAdvice`。4XX 表示客户端错误，5XX 表示服务器端错误，2XX 表示正确响应，3XX 表示重定向。

### 4xx 状态码说明
- **资源不存在（404 NOT_FOUND）**：在必须的父级数据不存在或地址不存在时响应。
- **权限不足（403 FORBIDDEN）**：在指定操作没有权限时响应。
- **校验失败（422 UNPROCESSABLE_ENTITY）**：在提交的数据校验失败或业务前提条件不足时响应。
- **服务器错误（500 INTERNAL_SERVER_ERROR）**：在服务器端出现错误，应由程序员解决时响应。

### 2xx 使用说明
2xx 状态码暂定只使用 200 一个状态。只要服务器能正确处理请求，并且处理正确，则响应 200 状态码。在特定场景下的处理结果被拒绝，需要给出拒绝理由的场景，服务器应响应 200，并在结果中描述清楚结果代码以及原因。

### REST API 设计
- **创建（POST /XXX）**：响应为 200 OK 表示资源被创建，成功时响应创建的资源，拒绝时响应失败原因并带有 4xx 状态。
- **读取（GET /XXX）**：响应为 200 OK 表示资源被读取到，成功时响应此资源，拒绝时响应失败原因并带有 4xx 状态。
- **更新（PUT /XXX）**：响应为 200 OK 表示全量修改一个资源，此类操作接口幂等，成功时不响应任何结果，拒绝时响应失败原因并带有 4xx 状态。
- **修改（PATCH /XXX）**：响应为 200 OK 表示局部更新一个资源，此接口可返回资源处理结果，拒绝时响应失败原因并带有 4xx 状态。
- **删除（DELETE /XXX）**：响应为 200 OK 表示资源被删除，成功时不响应任何结果，拒绝时响应失败原因并带有 4xx 状态。

### 微服务调用交互
内部定义了 `@AsInnerApi` 注解用于标记一个 endpoint 为内部 API，
这类 API 通常用于提供给内部其他服务调用。
- 这类API会添加前缀`/inner`
- 这类API不会注册到网关，通常也不会校验权限（自己在方法上控制权限即可）
- 这类API不会复合rest风格，通常是面向命令方式的。


内部定义了`@AsRestApi`注解用于标记一个endpoint 为客户端 API，
这类API通常用于提供给终端层，常见为浏览器端调用。

- 这类API会添加前缀`/rest`
- 这类API会被注册到网关，通常也会校验权限（自己在方法上控制权限即可）
- 这类API会一定程度上遵循rest风格。

## 常见问题

**分许需求的时候（实时/写操作/强一致）（异步/写操作/最终一致）（异步/只读） 这些都是干什么用的？**

-   **实时/写操作/强一致**：这几个条件几乎都是同时出现的，出现之后通常意味着单体应用下会设计通过直接调用领域服务处理操作，且在同一个数据库事务中。
-   **异步/写操作/最终一致**： 这种情况下，可以考虑异步写入MQ，然后订阅处理，通常都是业务实时性要求不高，但是数据处理量较大，异步处理有助于性能提升。
-   **异步/只读** ： 绝大多数可以说是一种通知场景，没有同步处理的意义，所以异步操作即可以满足提高性能，又可以分离出单独服务有助于解耦。

**为什么领域层不分单独的包，比如 /repository /entity ?**

> 领域层的逻辑很复杂，复杂的东西都在这里，难道我实现24种设计模式要创建24个包吗？

**领域层的拦截器机制会不会污染核心逻辑？**

> 是不是核心逻辑取决于你的设计，不取决于技术手段，没有那种设计模式能拦得住你瞎胡乱写。

**为什么领域服务不命名为DomainService？**

> 领域驱动是教你如何应对复杂软件的，这个过程包括：统一语言，建模，解耦实现。但不是《程序员装逼指南》，是哲学，不是数学。 如果你认真研究过DDD就会发现，拘泥于命名和分包而不是思想战术的话，只会万劫不复，堕走火入魔。

**架构师让我们写文档这段，你想表达什么？**

> 《敏捷开发》书中说过，要写最重要的文档，而不是流水账的海量文档，这种核心设计文档可以用来推导出所有代码，但是海量的流水文档一旦疏于管理，更加百害而无一益。

**你是不是想告诉我门 DDD 不只适用于互联网？**

> 我想告诉你DDD不适用于互联网。

### Docker 配置
项目提供了 Docker 配置文件，方便进行容器化部署。`src/docker/eleven/docker - compose.yml` 定义了 Redis、Upms 和 Demo 等服务的配置。

## 使用建议
1. 在 `eleven-framework` 模块中扩展基础框架功能，如添加新的安全认证方式、日志处理方式等。
2. 按照 DDD 的思想，在 `eleven-service` 模块中添加具体的业务功能。
3. 首先在特定的应用服务下面创建core/common包，编写该服务需要的公共代码，core代表着业务无关的代码，common代表着业务相关的代码。
4. 定期反思重构将core包的代码沉淀到`eleven-framework`来完成技术沉淀。
5. 定期反思重构将common包的代码沉淀到自己的业务组件包中。
