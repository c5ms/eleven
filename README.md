
# 🛠️ Eleven
**低成本可落地的领域驱动设计（DDD）技术方案脚手架**


## 📖 项目介绍
Eleven 是一套遵循领域驱动设计（DDD）理念的工程化脚手架，旨在通过标准化架构设计，帮助开发者快速构建可维护、易扩展的企业级应用。核心设计原则如下：

### 🌟 分层架构设计规范
1. **清晰的层次架构与职责分离**
   采用经典四层架构，各层边界明确、职责单一：
    - **用户界面层（UI Layer）** 🖥️
      专注用户交互（Web/API/CLI），负责输入校验、DTO与领域模型转换，禁止包含任何业务逻辑，仅调用应用层接口。
    - **应用层（Application Layer）** 🧩
      作为流程协调者，定义粗粒度服务（如订单创建、权限校验），处理事务边界、日志监控，依赖领域层抽象接口，不涉及核心业务逻辑。
    - **领域层（Domain Layer）** 🏰
      封装业务核心，包含实体、值对象、聚合根、领域服务及领域事件，独立于技术实现，通过抽象接口与基础设施层交互。
    - **基础设施层（Infrastructure Layer）** ⚙️
      提供技术支撑（数据库、消息队列、外部集成），实现上层定义的抽象接口（如仓储接口），支持透明替换（如从MySQL切换至MongoDB）。

2. **依赖倒置与单向依赖**
    - 上层依赖下层抽象（如应用层依赖领域层定义的`UserRepository`接口，而非基础设施层的`MySQLUserRepository`实现）。
    - 严格禁止反向依赖（基础设施层不得依赖领域层/应用层），确保技术细节不污染业务核心。

3. **领域模型纯净性保障**
    - 领域对象（实体/值对象）不包含技术注解（如JPA的`@Entity`），业务逻辑与数据存储解耦。
    - 通过防腐层（ACL）隔离外部系统，将第三方数据模型转换为领域模型，避免外部逻辑渗透。

4. **层间协作规范**
    - 接口定义使用领域通用语言（Ubiquitous Language），如`OrderId`而非`Long orderId`，确保语义与业务对齐。
    - 通过数据传输对象（DTO）解耦层间数据格式，UI层与应用层交互仅使用DTO，禁止直接暴露领域模型。
    - 禁止跨层直接调用（如UI层不得绕过应用层访问领域层服务），确保层次边界清晰。

5. **可演进性设计**
    - 各层支持独立演进：更换UI框架、数据库或消息中间件时，仅需修改对应层实现，不影响其他层次。
    - 业务规则与技术规则分离：核心逻辑集中在领域层，事务管理、资源调度等技术细节下沉至基础设施层或应用层。


## 🧱 分层设计细则
### 包结构规范（以Java为例）
```plaintext
- xxxService         # 应用层服务（Bean级别，@Service）
  - xxxManager       # 领域服务（Bean级别，封装跨聚合业务逻辑，非DDD标准领域层，属应用层下沉）
    - xxxSupport     # 业务公共方法类（Bean级别，跨模块通用逻辑）
      - xxxEr/Or     # 业务工具类（无层级依赖，业务专属工具）
        - xxxUtil    # 通用静态工具类（与业务无关，如字符串处理）
        - xxxHelper  # 业务相关静态工具类（如订单号生成）
        - xxxContext # 框架相关工具类（如Spring上下文工具）
```

![Arch-service-The_arch_of_a_service.png](doc/img/Arch-service-The_arch_of_a_service.png)

## 🔗 聚合设计核心原则
### 🌟 领域对象建模规则
#### 🗄️ 实体（Entity）
- 拥有唯一标识符（ID），通过业务操作显式管理生命周期，避免贫血模型。
- 聚合内ID局部唯一，由聚合根统一管理；禁止直接引用其他聚合实体，通过聚合根ID关联。

#### 🔑 聚合根（Aggregate Root）
- 聚合的**唯一访问入口**，外部仅能通过ID操作聚合内对象。
- 持有全局唯一ID，控制聚合内实体生命周期，确保业务规则在聚合边界内校验。
- 设计遵循“最小化原则”，避免包含无关实体，外部引用仅通过ID关联。

#### 📊 值对象（Value Object）
- 无唯一标识，通过属性值定义身份，创建后不可变（修改需创建新实例）。
- 作为数据载体存在，通过属性值比较相等性（而非引用地址）。

#### ⚙️ 领域服务（Domain Service）
- 封装跨实体/聚合的复杂业务逻辑，不依赖技术细节（如事务、UI）。
- 依赖的技术能力通过抽象接口注入（如仓储接口），保持业务纯粹性。

### 🚀 技术实现规范
#### 领域模型必选要素
- 包含实体、聚合根、仓储接口、领域事件，以及聚合根的读写操作能力。
- 业务规则集中在领域层，技术实现（如JPA）下沉至基础设施层。

#### 技术选型策略
- **持久化**：使用JPA标记实体类（当前团队技术栈适配，暂不考虑存储技术解耦）。
- **读写分离**：基于CQRS实现，严格区分读操作（查询）与写操作（命令），保证单一职责。
- **领域服务命名**：以`Manager`后缀命名（如`OrderManager`），与应用层`Service`区分。
- **领域事件管理**：通过领域服务代理事件发布，由基础设施层实现事件总线。


## 🚪 接口设计规范
### 📡 状态码约定
采用HTTP标准状态码，统一由`RestApiAdvice`处理器处理：
| 分类       | 状态码范围 | 说明                     |
|------------|------------|--------------------------|
| **成功**   | 2xx        | 200 OK（统一成功响应）   |
| **客户端错误** | 4xx        | 404（资源不存在）、403（权限不足）、422（参数校验失败） |
| **服务器错误** | 5xx        | 500 INTERNAL_SERVER_ERROR（服务端异常） |

### 🧭 REST API 设计原则
| 操作类型   | 方法  | 路径       | 响应规范                          |
|------------|-------|------------|-----------------------------------|
| 创建       | POST  | `/XXX`     | 200 OK（返回创建的资源或失败原因）|
| 读取       | GET   | `/XXX`     | 200 OK（返回资源或失败原因）      |
| 全量更新   | PUT   | `/XXX`     | 200 OK（幂等操作，无响应体）      |
| 局部更新   | PATCH | `/XXX`     | 200 OK（返回更新结果或失败原因）  |
| 删除       | DELETE| `/XXX`     | 200 OK（无响应体，失败时返回原因）|

### 🔄 微服务交互规范
#### 内部API（`@AsInnerApi`）
- 前缀：`/inner`
- 特性：不注册到网关，权限自管理，支持非REST风格（面向命令）。

#### 客户端API（`@AsRestApi`）
- 前缀：`/rest`
- 特性：注册到网关，统一权限校验，遵循REST规范。


## ❓ 常见问题解答
### Q：如何理解需求分类（实时/异步、读写操作、一致性）？
- **实时/写操作/强一致** 🚀：单体应用中通过同步调用领域服务，在同一事务中保证数据一致性（如订单支付即时生效）。
- **异步/写操作/最终一致** ⏳：通过消息队列（MQ）异步处理，适用于实时性要求低、高吞吐量场景（如异步日志记录）。
- **异步/只读** 🔄：纯通知类场景，异步处理提升性能并解耦服务（如邮件通知）。

### Q：为何领域层不分`/repository`/`/entity`包？
> 领域层的复杂度源于业务逻辑而非技术分层。过度拆分包结构可能导致“模式滥用”，核心是通过聚合、领域服务等DDD工具管理复杂性，而非机械套用目录结构。

### Q：领域层拦截器会污染核心逻辑吗？
> 核心逻辑的纯净性取决于设计决策，而非技术手段。合理使用AOP（如事务管理）下沉技术细节，确保领域对象专注业务规则，避免混杂日志、权限等横切逻辑。

### Q：为何领域服务不命名为`DomainService`？
> DDD的核心是“统一语言”与“解耦”，而非僵化命名。`Manager`等命名更贴合团队通用语言，关键是通过接口清晰区分领域服务与应用服务的职责边界。

### Q：为何强调核心技术文档而非海量文档？
> 遵循敏捷原则，核心设计文档（如领域模型、分层规则）需精确推导代码实现，而流水账文档易过时且难维护，聚焦“必要文档”而非形式主义。

### Q：DDD仅适用于互联网领域吗？
> 恰恰相反，DDD的价值在复杂业务场景（如金融、制造业）更为显著。互联网应用常因过度简化忽略领域建模，导致后期维护成本激增。


## 🐳 Docker 配置
项目提供容器化部署支持，核心配置位于：
`src/docker/eleven/docker-compose.yml`
包含Redis、Upms、Demo等服务的容器编排定义，支持一键启动。


## 💡 使用建议
1. **框架扩展**：在`eleven-framework`模块中封装通用技术能力（安全认证、日志处理）。
2. **业务实现**：按DDD规范在`eleven-service`模块中构建领域模型，优先在应用服务下创建`core`（业务无关公共代码）与`common`（业务相关公共代码）包。
3. **持续沉淀**：定期将`core`包代码提炼至`eleven-framework`，`common`包代码沉淀为业务组件，避免重复造轮。
4. **代码评审**：严格按照分层规则与领域模型设计原则进行评审，确保架构不腐化。



通过Eleven脚手架，团队可快速落地DDD最佳实践，聚焦业务建模而非架构搭建，在复杂业务场景中保持系统的可演进性与可维护性。🚀
