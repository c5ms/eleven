消息驱动机制（也可提说是事件驱动机制的异步表现形式），可以按照几个纬度来考虑


### 消息发送的挑战
- 时序问题
- 一致性问题
- 失败处理问题

## 消息发送的时机

### 在事务之内发送
消息在事务之内发送，可以保证消息一定被顺利投敌之后才写入数据库，此时消息需要带有必要的数据状态，可能会增加消息复杂性。

这种处理通常消息非常重要，绝对不可以丢失。一般用在用户敏感数据上，比如银行交易。

**优势**
- 保证数据库写入之后消息一定被顺利发送出去

**劣势**
- 需要增加消息属性来传递数据状态
- 会增加消息处理的时序性问题。

### 在事务之后发送

此时消息在事务被提交之后发送，下游应用可以通过数据ID读取数据，保证得到最终数据状态，一定程度上解决了时许问题，但是生产者无法保证消息一定被顺利投敌到消息中心。

这种处理一般用在价值不是很高的数据上，比如给用户增加经验值。

**优势**
- 可以保证消费者拿到消息的时候可以读取到数据最终状态，一定程度可以减轻时序问题

**劣势**
- 无法保证消息一定可以被投敌到目标消息系统。

## 消息设计的模式

### 命令式
在命令式消息模式下,消息以命令的形式被定义，消息本身包含下游消费者需要处理的逻辑单元描述，此时后续处理的主控权在上游应用，比如如下消息
消费方根据jobs字段来执行后续逻辑。
```java
class ReviewCommand{
    String planId;
    Set<String> jobs;
}
```

 **优势**
- 可以在上游应用对下游消费端处理逻辑进行合并处理，避免不必要的重复逻辑

**劣势**
- 修改逻辑的时候上下游应用需要一同修改，此时上下游处于耦合状态


### 响应式

在响应式模式下，消息以事件的形式出现，消息本身只包含上游应用发生的事件，后续逻辑由下游应用来处理，比如如下消息
```java
class PlanCreatedEvent{
    String planId;
}
```

**优势**
- 可以在不修改消息的情况下增加下游应用消费逻辑，此时上下游应用处于松耦合状态

**劣势**
- 下游应用有可能在不同事件之间出现重复逻辑处理，造成资源浪费。
